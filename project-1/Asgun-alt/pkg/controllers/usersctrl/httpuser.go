package usersctrl

import (
	"errors"
	"net/http"

	"github.com/gnumi34/golang-mentoring/tree/main/project-1/Asgun-alt/pkg/domain"
	"github.com/gnumi34/golang-mentoring/tree/main/project-1/Asgun-alt/pkg/domain/request"
	"github.com/gnumi34/golang-mentoring/tree/main/project-1/Asgun-alt/pkg/helper/err"
	"github.com/gnumi34/golang-mentoring/tree/main/project-1/Asgun-alt/pkg/helper/validate"
	"github.com/gnumi34/golang-mentoring/tree/main/project-1/Asgun-alt/pkg/service/uservice"
	"github.com/labstack/echo/v4"
)

var (
	badRequest = http.StatusBadRequest
)

type UserController struct {
	usecase uservice.UsersUsecaseInterface
}

func NewUserController(userUsecase uservice.UsersUsecaseInterface) *UserController {
	return &UserController{usecase: userUsecase}
}

// GetUser godoc
// @Summary      Show an account
// @Description  validate username and password, if user is exists in the database RETURN valid user
// @Tags         GetUser
// @Accept       json
// @Produce      json
// @Success      200
// @Router       /users/get-user [get]
func (controller *UserController) GetUser(c echo.Context) error {
	req := request.GetUser{}
	bindErr := c.Bind(&req)
	if bindErr != nil {
		return domain.ErrorResponse(c, badRequest, errors.New("data bind error"))
	}
	ctx := c.Request().Context()

	userData, result := controller.usecase.GetUser(ctx, req.ToGetUserDomain())
	if result != nil {
		errCode, errMessage := err.ErrorGetUserCheck(result)
		return domain.ErrorResponse(c, errCode, errMessage)
	}

	if userData.Username == "" || userData.Password == "" {
		return domain.ErrorResponse(c, http.StatusNotFound, errors.New("invalid user or user has been deleted"))
	}
	return domain.SuccessMessageResponse(c, "valid user")
}

// AddUsers godoc
// @Summary      Add user
// @Description  Add new user to the database, ID is generated by the API, password  is saved with BCrypt hash after passess validation.
// @Tags         Add new user
// @Accept       json
// @Produce      json
// @Success      200  {object}  uservice.UsersDomain
// @Router       /users/ [post]
func (controller *UserController) AddUsers(c echo.Context) error {
	req := request.AddUsers{}
	bindErr := c.Bind(&req)
	if bindErr != nil {
		return domain.ErrorResponse(c, badRequest, errors.New("data bind error"))
	}
	ctx := c.Request().Context()

	if validate.MustNotBeEmpty(req.Username) || validate.MustNotBeEmpty(req.Email) {
		return domain.ErrorResponse(c, badRequest, errors.New("username or email cannot be empty"))
	}
	if !validate.ValidateEmail(req.Email) {
		return domain.ErrorResponse(c, badRequest, errors.New("invalid email"))
	}
	if req.Password_1 != req.Password_2 {
		return domain.ErrorResponse(c, badRequest, errors.New("password didn't match"))
	}
	if !validate.ValidatePassword(req.Password_1) {
		return domain.ErrorResponse(c, badRequest, errors.New("password must have 1 uppercase letter, 1 number, 1 special character"))
	}

	_, result := controller.usecase.AddUsers(ctx, req.ToUserDomain())
	if result != nil {
		errCode, errMessage := err.CheckErrorAddUsers(result)
		return domain.ErrorResponse(c, errCode, errMessage)
	}
	return domain.SuccessOkResponse(c)
}

// UpdateUsers godoc
// @Summary      Update USER
// @Description  Update the user to the database.
// @Tags         Update User
// @Accept       json
// @Produce      json
// @Success      200  {object}  uservice.UsersDomain
// @Router       /users/ [put]
func (controller *UserController) UpdateUsers(c echo.Context) error {
	req := request.UpdateUsers{}
	bindErr := c.Bind(&req)
	if bindErr != nil {
		return domain.ErrorResponse(c, badRequest, errors.New("data bind error"))
	}

	if validate.MustNotBeEmpty(req.Username) {
		return domain.ErrorResponse(c, badRequest, errors.New("username or email cannot be empty"))
	}
	if req.Email != "" && !validate.ValidateEmail(req.Email) {
		return domain.ErrorResponse(c, badRequest, errors.New("invalid email"))
	}
	if req.Password_1 != req.Password_2 {
		return domain.ErrorResponse(c, badRequest, errors.New("password didn't match"))
	}
	if req.Password_1 != "" && !validate.ValidatePassword(req.Password_1) {
		return domain.ErrorResponse(c, badRequest, errors.New("password must have 1 uppercase letter, 1 number, 1 special character"))
	}

	ctx := c.Request().Context()
	_, result := controller.usecase.UpdateUsers(ctx, req.ToUpdateUserDomain())

	if result != nil {
		errCode, errMessage := err.ErrorUpdateUsersCheck(result)
		return domain.ErrorResponse(c, errCode, errMessage)
	}
	return domain.SuccessOkResponse(c)
}

// DeleteUsers godoc
// @Summary      Delete User
// @Description  Soft delete user by passing the user ID.
// @Tags         (Soft) Delete User
// @Accept       json
// @Params 		 id
// @Produce      json
// @Success      200
// @Router       /users/{id} [delete]
func (controller *UserController) DeleteUsers(c echo.Context) error {
	id := c.Param("id")

	ctx := c.Request().Context()
	result := controller.usecase.DeleteUsers(ctx, id)
	if result != nil {
		errCode, errMessage := err.ErrorDeleteUsersCheck(result)
		return domain.ErrorResponse(c, errCode, errMessage)
	}

	return domain.SuccessOkResponse(c)
}
