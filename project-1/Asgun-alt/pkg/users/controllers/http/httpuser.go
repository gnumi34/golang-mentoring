package users

import (
	"errors"
	"net/http"
	"strconv"

	"golang-mentoring/project-1/Asgun-alt/pkg/common/controller"
	"golang-mentoring/project-1/Asgun-alt/pkg/domain/users"
	"golang-mentoring/project-1/Asgun-alt/pkg/domain/users/request"
	"golang-mentoring/project-1/Asgun-alt/pkg/helper/errcode"
	"golang-mentoring/project-1/Asgun-alt/pkg/helper/validate"

	"github.com/labstack/echo/v4"
)

var (
	badRequest = http.StatusBadRequest
)

type UserController struct {
	handler controller.BaseController
	usecase users.UsersUsecaseInterface
}

func NewUserController(userUsecase users.UsersUsecaseInterface) *UserController {
	return &UserController{usecase: userUsecase}
}

// Protected route godoc
// @Summary      Protected user route
// @Description  Protected route can only be accessed if the the user has valid JWT token.
// @Param 		 Authorization header string true "Insert your access token 'Bearer your_token'"
// @Tags         Protected
// @Success      200
// @Router       /user/protected [get]
func (uc *UserController) Protected(c echo.Context) error {
	return uc.handler.SuccessMessageResponse(c, "hello this route is protected")
}

// GetUser godoc
// @Summary      Show an account
// @Description  validate username and password, if user is exists in the database RETURN valid user
// @Param 		 Authorization header string true "Insert your access token 'Bearer your_token'"
// @Param 		 User body request.GetUser true "validate user"
// @Tags         Get User
// @Accept       json
// @Produce      json
// @Success      200
// @Router       /users/get-user [post]
func (uc *UserController) GetUser(c echo.Context) error {
	req := request.GetUser{}
	bindErr := c.Bind(&req)
	if bindErr != nil {
		return uc.handler.ErrorResponse(c, badRequest, errors.New("bind data error"))
	}
	ctx := c.Request().Context()
	if req.Username == "" {
		return uc.handler.ErrorResponse(c, badRequest, errcode.ErrUsernameEmpty)
	}
	if req.Password == "" {
		return uc.handler.ErrorResponse(c, badRequest, errcode.ErrPasswordEmpty)
	}

	_, err := uc.usecase.GetUser(ctx, req.ToGetUserDomain())
	if err != nil {
		errCode, errMessage := errcode.ErrorGetUserCheck(err)
		return uc.handler.ErrorResponse(c, errCode, errMessage)
	}

	return uc.handler.SuccessMessageResponse(c, "valid user")
}

// AddUser godoc
// @Summary      Add user
// @Description  Add new user to the database, ID is generated by the API, password  is saved with BCrypt hash after passess validation.
// @Param 		 User body request.AddUser true "Add User"
// @Tags         Add User
// @Accept       json
// @Produce      json
// @Success      200  {object}  users.UsersDomain
// @Router       /users/ [post]
func (uc *UserController) AddUser(c echo.Context) error {
	req := request.AddUser{}
	bindErr := c.Bind(&req)
	if bindErr != nil {
		return uc.handler.ErrorResponse(c, badRequest, errors.New("bind data error"))
	}
	ctx := c.Request().Context()

	validErr := validate.Validator(req)
	if validErr != nil {
		return uc.handler.ErrorValidationResponse(c, badRequest, validErr)
	}
	if req.Username == "" {
		return uc.handler.ErrorResponse(c, badRequest, errcode.ErrUsernameEmpty)
	}
	if req.Password1 == "" || req.Password2 == "" {
		return uc.handler.ErrorResponse(c, badRequest, errcode.ErrPasswordEmpty)
	}
	if !validate.ValidatePassword(req.Password1) {
		return uc.handler.ErrorResponse(c, badRequest, errors.New("password must have 1 uppercase letter, 1 number, 1 special character"))
	}

	_, result := uc.usecase.AddUser(ctx, req.ToUserDomain())
	if result != nil {
		errCode, errMessage := errcode.CheckErrorAddUsers(result)
		return uc.handler.ErrorResponse(c, errCode, errMessage)
	}
	return uc.handler.SuccessOkResponse(c)
}

// UpdateUser godoc
// @Summary      Update User
// @Description  Update the user to the database.
// @Param 		 Authorization header string true "Insert your access token 'Bearer your_token'"
// @Param 		 User body request.UpdateUser true "Update User"
// @Tags         Update User
// @Accept       json
// @Produce      json
// @Success      200  {object}  users.UsersDomain
// @Router       /users/ [put]
func (uc *UserController) UpdateUser(c echo.Context) error {
	req := request.UpdateUser{}
	bindErr := c.Bind(&req)
	if bindErr != nil {
		return uc.handler.ErrorResponse(c, badRequest, errors.New("bind data error"))
	}

	if req.Password1 != "" || req.Password2 != "" {
		if req.Password1 == "" || req.Password2 == "" {
			return uc.handler.ErrorResponse(c, badRequest, errcode.ErrPasswordEmpty)
		}
		if req.Password1 != "" && !validate.ValidatePassword(req.Password1) {
			return uc.handler.ErrorResponse(c, badRequest, errors.New("password must have 1 uppercase letter, 1 number, 1 special character"))
		}
	}

	ctx := c.Request().Context()
	_, err := uc.usecase.UpdateUser(ctx, req.OldPassword, req.ToUpdateUserDomain())

	if err != nil {
		errCode, errMessage := errcode.ErrorUpdateUsersCheck(err)
		return uc.handler.ErrorResponse(c, errCode, errMessage)
	}
	return uc.handler.SuccessOkResponse(c)

}

// DeleteUser godoc
// @Summary      Delete User
// @Description  Soft delete user by passing the user ID.
// @Param 		 Authorization header string true "Insert your access token 'Bearer your_token'"
// @Param 		 id path string true "delete user"
// @Tags         (Soft) Delete User
// @Accept       json
// @Produce      json
// @Success      200
// @Router       /users/{id} [delete]
func (uc *UserController) DeleteUser(c echo.Context) error {
	var id int
	idStr := c.Param("id")
	id, err := strconv.Atoi(idStr)
	if err != nil {
		return uc.handler.ErrorResponse(c, badRequest, errors.New("invalid user id"))
	}

	ctx := c.Request().Context()
	result := uc.usecase.DeleteUser(ctx, uint(id))
	if result != nil {
		errCode, errMessage := errcode.ErrorDeleteUsersCheck(result)
		return uc.handler.ErrorResponse(c, errCode, errMessage)
	}
	return uc.handler.SuccessOkResponse(c)
}
