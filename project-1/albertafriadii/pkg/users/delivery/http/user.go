package http

import (
	"errors"
	"fmt"
	"net/http"
	"regexp"

	"github.com/albertafriadii/tree/fix/albertafriadii/pkg/config"
	"github.com/albertafriadii/tree/fix/albertafriadii/pkg/domain"
	"github.com/go-playground/locales/en"
	ut "github.com/go-playground/universal-translator"
	"github.com/go-playground/validator/v10"
	en_trans "github.com/go-playground/validator/v10/translations/en"
	"github.com/labstack/echo/v4"
)

type UserController struct {
	usecase domain.UserUsecaseInterface
}

func NewUserController(u domain.UserUsecaseInterface) *UserController {
	return &UserController{usecase: u}
}

// GetUser godoc
// @Summary      Show an account
// @Description  validate username and password, if user is exists in the database RETURN valid user
// @Tags         GetUser
// @Accept       json
// @Produce      json
// @Success      200
// @Failure		 400
// @Router       /user/get [get]
func (c *UserController) GetUser(ctx echo.Context) error {
	u := domain.GetUser{}
	bindErr := ctx.Bind(&u)
	if bindErr != nil {
		return domain.ErrResponse(ctx, http.StatusBadRequest, errors.New("data bind error"))
	}

	_, err := c.usecase.GetUser(ctx.Request().Context(), u.ToGetUserDomain())
	if err != nil {
		errStatus, errMessage := config.ErrGetUserCheck(err)
		fmt.Println(err)
		return domain.ErrResponse(ctx, errStatus, errMessage)
	}
	return domain.SuccessMessageResponse(ctx, "Valid User")
}

// CreateUser godoc
// @Summary      Create user
// @Description  Create new user to the database, ID is generated by the API, password  is saved with BCrypt hash after passess validation.
// @Tags         Create new user
// @Accept       json
// @Produce      json
// @Success      200  {object}  domain.Users
// @Failure		 400 {object} domain.ErrResponse
// @Router       /user/ [post]
func (c *UserController) CreateUser(ctx echo.Context) error {
	u := domain.InputCreateUser{}
	bindErr := ctx.Bind(&u)
	if bindErr != nil {
		return domain.ErrResponse(ctx, http.StatusBadRequest, errors.New("data bind error"))
	}

	uni := ut.New(en.New())
	trans, _ := uni.GetTranslator("en")
	validate := validator.New()

	err := en_trans.RegisterDefaultTranslations(validate, trans)
	if err != nil {
		return domain.ErrResponse(ctx, http.StatusBadRequest, err)
	}

	err = validate.Struct(u)
	if err != nil {
		errResult := []string{}
		for _, err := range err.(validator.ValidationErrors) {
			errResult = append(errResult, err.Translate(trans))
		}
		if len(errResult) > 0 {
			return ctx.JSON(http.StatusBadRequest, domain.Response{Error: errResult})
		}
	}

	num, _ := regexp.Compile(`[0-9]+?`)
	resNum := num.MatchString(u.Password)
	sym, _ := regexp.Compile(`[^a-zA-Z0-9]+?`)
	resSym := sym.MatchString(u.Password)
	upper, _ := regexp.Compile(`[A-Z]+?`)
	resUpper := upper.MatchString(u.Password)

	if u.Password != u.Repassword {
		return domain.ErrResponse(ctx, http.StatusBadRequest, errors.New("Password not match"))
	}

	if !resNum || !resSym || !resUpper {
		return domain.ErrResponse(ctx, http.StatusBadRequest, errors.New("Must be at least 8 letters, alphanumeric + symbol, has at least 1 uppercase letter, has at least 1 number, and has at least 1 symbol."))
	}

	_, err = c.usecase.CreateUser(ctx.Request().Context(), u.ToCreateUserDomain())
	if err != nil {
		errStatus, errMessage := config.ErrCreateUserCheck(err)
		return domain.ErrResponse(ctx, errStatus, errMessage)
	}
	return domain.OkResponse(ctx)
}

// UpdateUser godoc
// @Summary      Update user
// @Description  Update the user to the database passing by user ID
// @Tags         Update User
// @Accept       json
// @Params 		 user_id
// @Produce      json
// @Success      200  {object}  domain.Users
// @Router       /user/{user_id} [put]
func (c *UserController) UpdateUser(ctx echo.Context) error {
	u := domain.InputUpdateUser{}
	bindErr := ctx.Bind(&u)
	if bindErr != nil {
		return domain.ErrResponse(ctx, http.StatusBadRequest, errors.New("data bind error"))
	}

	uni := ut.New(en.New())
	trans, _ := uni.GetTranslator("en")
	validate := validator.New()

	err := en_trans.RegisterDefaultTranslations(validate, trans)
	if err != nil {
		return domain.ErrResponse(ctx, http.StatusBadRequest, err)
	}

	err = validate.Struct(u)
	if err != nil {
		errResult := []string{}
		for _, err := range err.(validator.ValidationErrors) {
			errResult = append(errResult, err.Translate(trans))
		}
		if len(errResult) > 0 {
			return ctx.JSON(http.StatusBadRequest, domain.Response{Error: errResult})
		}
	}

	// num, _ := regexp.Compile(`[0-9]+?`)
	// resNum := num.MatchString(u.Password)
	// sym, _ := regexp.Compile(`[^a-zA-Z0-9]+?`)
	// resSym := sym.MatchString(u.Password)
	// upper, _ := regexp.Compile(`[A-Z]+?`)
	// resUpper := upper.MatchString(u.Password)

	// if u.Password != u.Repassword {
	// 	return domain.ErrResponse(ctx, http.StatusBadRequest, errors.New("Password not match"))
	// }

	// if !resNum || !resSym || !resUpper {
	// 	return domain.ErrResponse(ctx, http.StatusBadRequest, errors.New("Must be at least 8 letters, alphanumeric + symbol, has at least 1 uppercase letter, has at least 1 number, and has at least 1 symbol."))
	// }

	userID := ctx.Param("user_id")

	_, err = c.usecase.UpdateUser(ctx.Request().Context(), u.ToUpdateUserDomain(), userID)
	if err != nil {
		errStatus, errMessage := config.ErrUpdateUserCheck(err)
		return domain.ErrResponse(ctx, errStatus, errMessage)
	}
	return domain.OkResponse(ctx)
}

// DeleteUser godoc
// @Summary      Delete User
// @Description  Soft delete user by passing the user ID.
// @Tags         (Soft) Delete User
// @Accept       json
// @Produce      json
// @Param		 user_id path string true "UserID"
// @Success      200 {object} domain.OkResponse
// @Router       /user/{user_id} [delete]
func (c *UserController) DeleteUser(ctx echo.Context) error {
	userID := ctx.Param("user_id")

	err := c.usecase.DeleteUser(ctx.Request().Context(), userID)
	if err != nil {
		errStatus, errMessage := config.ErrDeleteUserCheck(err)
		return domain.ErrResponse(ctx, errStatus, errMessage)
	}
	return domain.OkResponse(ctx)
}
