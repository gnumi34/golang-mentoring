package http

import (
	"errors"
	"fmt"
	"net/http"
	"strconv"

	"golang-mentoring/project-1/albertafriadii/pkg/config"
	"golang-mentoring/project-1/albertafriadii/pkg/domain"

	"github.com/labstack/echo/v4"
)

type UserController struct {
	usecase domain.UserUsecaseInterface
}

func NewUserController(u domain.UserUsecaseInterface) *UserController {
	return &UserController{usecase: u}
}

// FindAll godoc
// @Summary      Find all users
// @Description  Find all users
// @Tags         FindAll
// @Produce      json
// @Success      200
// @Failure		 400
// @Router       /user/findall [get]
func (c *UserController) FindAll(ctx echo.Context) error {
	users, err := c.usecase.FindAll(ctx.Request().Context())
	if err != nil {
		if errors.Is(err, config.ErrNotFound) {
			return domain.ErrResponse(ctx, http.StatusNotFound, config.ErrNotFound)
		}

		return domain.ErrResponse(ctx, http.StatusInternalServerError, config.ErrInternalServerError)
	}

	return domain.SuccessDataResponse(ctx, users)
}

// LoginUser godoc
// @Summary      Show an account
// @Description  validate username and password with JWT Token to authentication user.
// @Tags         LoginUser
// @Param		 User body domain.GetUser true "validate user"
// @Accept       json
// @Produce      json
// @Success      200
// @Failure		 400
// @Router       /user/login [get]
func (c *UserController) LoginUser(ctx echo.Context) error {
	u := domain.GetUser{}
	bindErr := ctx.Bind(&u)
	if bindErr != nil {
		return domain.ErrResponse(ctx, http.StatusBadRequest, errors.New("data bind error"))
	}

	if u.Username == "" {
		return domain.ErrResponse(ctx, http.StatusBadRequest, config.ErrUsernameEmpty)
	}

	if u.Password == "" {
		return domain.ErrResponse(ctx, http.StatusBadRequest, config.ErrPasswordEmpty)
	}

	res, err := c.usecase.LoginUser(ctx.Request().Context(), &u)
	if err != nil {
		errStatus, errMessage := config.ErrGetUserCheck(err)
		fmt.Println(err)
		return domain.ErrResponse(ctx, errStatus, errMessage)
	}

	return domain.SuccessDataResponse(ctx, res)
}

// CreateUser godoc
// @Summary      Create user
// @Description  Create new user to the database, ID is generated by the API, password  is saved with BCrypt hash after passess validation.
// @Tags         Create new user
// @Param		 User body domain.InputCreateUser true "create user"
// @Accept       json
// @Produce      json
// @Success      200  {object}  domain.Users
// @Failure		 400
// @Router       /user/ [post]
func (c *UserController) CreateUser(ctx echo.Context) error {
	u := domain.InputCreateUser{}
	bindErr := ctx.Bind(&u)
	if bindErr != nil {
		return domain.ErrResponse(ctx, http.StatusBadRequest, errors.New("data bind error"))
	}

	validationErr := config.Validator(u)
	if validationErr != nil {
		return domain.ErrValidResponse(ctx, http.StatusBadRequest, validationErr)
	}

	if !config.ValidationPassword(u.Password) {
		return domain.ErrResponse(ctx, http.StatusBadRequest, errors.New("Password must have at least 8 letters, alphanumeric + symbol, has at least 1 uppercase letter, has at least 1 number, and has at least 1 symbol."))
	}

	if !config.ValidationPassword(u.Repassword) {
		return domain.ErrResponse(ctx, http.StatusBadRequest, errors.New("Password must have at least 8 letters, alphanumeric + symbol, has at least 1 uppercase letter, has at least 1 number, and has at least 1 symbol."))
	}

	if u.Password != u.Repassword {
		return domain.ErrResponse(ctx, http.StatusBadRequest, config.ErrPasswordNotMatch)
	}

	_, err := c.usecase.CreateUser(ctx.Request().Context(), u.ToCreateUserDomain())
	if err != nil {
		errStatus, errMessage := config.ErrCreateUserCheck(err)
		return domain.ErrResponse(ctx, errStatus, errMessage)
	}
	return domain.OkResponse(ctx)
}

// UpdateUser godoc
// @Summary      Update user
// @Description  Update the user to the database passing by user ID
// @Tags         Update User
// @Param		 User body domain.InputUpdateUser true "update user"
// @Accept       json
// @Params 		 user_id
// @Produce      json
// @Success      200  {object}  domain.Users
// @Failure		 400
// @Router       /user/{user_id} [put]
func (c *UserController) UpdateUser(ctx echo.Context) error {
	var userID int
	var err error
	var u domain.InputUpdateUser

	UserID := ctx.Param("user_id")
	userID, err = strconv.Atoi(UserID)
	if err != nil {
		return domain.ErrResponse(ctx, http.StatusBadRequest, errors.New("Invalid ID"))
	}

	bindErr := ctx.Bind(&u)
	if bindErr != nil {
		return domain.ErrResponse(ctx, http.StatusBadRequest, errors.New("data bind error"))
	}

	validationErr := config.Validator(u)
	if validationErr != nil {
		return domain.ErrValidResponse(ctx, http.StatusBadRequest, validationErr)
	}

	if uint(userID) != u.UserId {
		return domain.ErrResponse(ctx, http.StatusBadRequest, errors.New("Invalid ID"))
	}

	if u.Username == "" {
		return domain.ErrResponse(ctx, http.StatusBadRequest, config.ErrUsernameEmpty)
	}

	if u.ExistingPassword != "" {
		if u.Password == "" {
			return domain.ErrResponse(ctx, http.StatusBadRequest, config.ErrPasswordEmpty)
		}

		if u.Password != u.Repassword {
			return domain.ErrResponse(ctx, http.StatusBadRequest, config.ErrPasswordNotMatch)
		}

		if !config.ValidationPassword(u.Password) && u.Password != "" {
			return domain.ErrResponse(ctx, http.StatusBadRequest, errors.New("Password must have at least 8 letters, alphanumeric + symbol, has at least 1 uppercase letter, has at least 1 number, and has at least 1 symbol."))
		}
	} else {
		u.Password, u.Repassword = "", ""
	}

	err = c.usecase.UpdateUser(ctx.Request().Context(), u.ExistingPassword, u.ToUpdateUserDomain())
	if err != nil {
		errStatus, errMessage := config.ErrUpdateUserCheck(err)
		return domain.ErrResponse(ctx, errStatus, errMessage)
	}
	return domain.OkResponse(ctx)
}

// DeleteUser godoc
// @Summary      Delete User
// @Description  Soft delete user by passing the user ID.
// @Tags         (Soft) Delete User
// @Accept       json
// @Produce      json
// @Param		 user_id path string true "UserID"
// @Success      200 {object} domain.Users
// @Failure		 400
// @Router       /user/{user_id} [delete]
func (c *UserController) DeleteUser(ctx echo.Context) error {
	var userID int
	var err error

	UserID := ctx.Param("user_id")
	userID, err = strconv.Atoi(UserID)
	if err != nil {
		return domain.ErrResponse(ctx, http.StatusBadRequest, errors.New("Invalid ID"))
	}

	err = c.usecase.DeleteUser(ctx.Request().Context(), uint(userID))
	if err != nil {
		errStatus, errMessage := config.ErrDeleteCheck(err)
		return domain.ErrResponse(ctx, errStatus, errMessage)
	}
	return domain.OkResponse(ctx)
}
